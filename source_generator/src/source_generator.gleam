/// Code of source generation
/// That example of source generation api
/// I don't tried to think through well on it
/// So it's not final version of api
/// It's a lot info that can be provided additionally
/// More is better
import gleam/io
import gleam/list
import gleam/result
import gleam/string

pub type FunctionParameter {
  FunctionParameter(parametr_name: String, parametr_type: GleamType)
}

pub type Scope {
  Pub
  Private
}

pub type FunctionData {
  FunctionData(
    name: String,
    parameters: List(FunctionParameter),
    return_type: GleamType,
    module_name: String,
    scope: Scope,
  )
}

pub type FunctionParameterValue {
  FunctionParameterValue(
    parametr_name: String,
    parametr_data: String,
    parametr_type: GleamType,
  )
}

pub type GleamType {
  String
  Bool
  Int
  List(list_type: GleamType)
  Function(function_data: FunctionData)
  CustomType(info: CustomTypeInfo)
  Generic(name: String)
  //i'm not sure it's all gleam types
}

pub type RecordData {
  RecordData(
    type_name: String,
    record_name: String,
    parameters: List(FunctionParameter),
  )
}

pub type CustomTypeInfo {
  CustomTypeInfo(
    type_name: String,
    records: List(RecordData),
    generics_type: List(String),
  )
}

pub type ModuleInfo {
  ModuleInfo(functions: List(FunctionData), types: List(CustomTypeInfo))
}

pub type PlaceGeneration {
  /// for type write as new record or replace existing records
  /// for functions write code in body of function
  /// for module write code in body of module but below of imports
  /// for new generated modules add new modules if module exist it don't rewriting
  /// for regex add new code nearby matched text
  Inner
  /// for type replace whole code of with generated code. Inner write or replace records, but Replace replace even "type SomeTypeDecloration"
  /// for functions replace whole function
  /// for moduel replace whole module, even imports
  /// for generated modules replace all modules generated by certain function
  /// for regex replace all matched text
  Replace
  /// for type add some new records above existing records or create them if they dont
  /// for function add code inner function body to above existing code
  /// for module add code above all code in module but not above of imports
  /// for generated modules work as Inner
  /// write above matched regex text
  Above
  /// for type add some new record below existinng recored or create them if they dont
  /// for function add code inner function body to below existing code
  /// for module add code below existing code 
  /// for generated modules work as Inner
  /// write below matched regex text
  Below
}

/// external proccess for source generation
/// that can run or through cli or while compile, 
/// depends on parametr for attribute @generate()
pub fn main() {
  //some main stuff that may be needed for source generator
  io.println("Hello from source_generator!")
}

pub type RegexSourceGeneratorData {
  RegexSourceGeneratorData(place: PlaceGeneration, code: String)
}

/// that source generator function call to generate new code, 
/// pass function data that can access to compile time 
/// and returned string is passed
/// about attribute_parameters
/// that arguments needed because
/// not all info you can get while compile time
/// so dev need to provide some additional info
/// 
/// json deserelization of example usage
/// it may work or not, i don't know
/// just example
/// dont try to fully understand this code
/// just see how source generator api can be used 
pub fn generate_json_deserelization(
  _place_generation: PlaceGeneration,
  function_data: FunctionData,
  _module_data: ModuleInfo,
  attribute_parameters: List(#(String, String)),
) -> Result(String, String) {
  let find_input_handler = fn(parametr: FunctionParameter) {
    parametr.parametr_type == String && parametr.parametr_name == "json_input"
  }
  //string error passed as comment
  //like
  let some_function_with_source_generation_error = fn() {
    //Generic types not supported
    todo
  }
  case list.find(function_data.parameters, find_input_handler) {
    Error(_) -> Error("Parametr type of String with name json_input not found")
    Ok(json_input_parametr) -> {
      gleam_type_to_json_type(
        json_input_parametr.parametr_name,
        function_data.return_type,
        attribute_parameters,
      )
    }
  }
}

/// json deserelization of example usage
/// it may work or not, i don't know
/// just example
/// dont try to fully understand this code
/// just see how source generator api can be used 
fn gleam_custom_type_to_json(
  json_input_parametr_name: String,
  type_name: String,
  records: List(RecordData),
  attribute_parameters: List(#(String, String)),
) {
  let find_record = fn(record_data: RecordData) {
    record_data.type_name == type_name
  }
  case list.find(records, find_record) {
    Error(_) -> Error("cannot find record by name")
    Ok(record_data) -> {
      let json_obj_params =
        list.map(record_data.parameters, fn(parameter) {
          case
            gleam_type_to_json_type(
              json_input_parametr_name,
              parameter.parametr_type,
              attribute_parameters,
            )
          {
            Error(error) -> Error(error)
            Ok(json_code) -> {
              "dynamic.field(\"{field_name}\", {json_type})"
              |> replace("field_name", parameter.parametr_name)
              |> replace("json_type", json_code)
              |> Ok()
            }
          }
        })
      let join_params = string.join(json_obj_params |> result.values(), ",")
      let params_count = list.length(json_obj_params)
      "
        let decoder = decode{params_count}({record_name}, {joined_params})
        let body = decode({input_parametr_name}, decoder)
        case body {
          Error(error) -> CouchError(error) |> Error()
          Ok(parsed_body) -> Ok(parsed_body)
        }
      "
      |> replace("params_count", params_count)
      |> replace("record_name", record_data.record_name)
      |> replace("joined_params", join_params)
      |> replace("{input_parametr_name}", json_input_parametr_name)
      |> Ok()
    }
  }
}

/// that code generated or below type or generated in roundwith brackets
/// depend on parametr in @generate above custom type
/// 
pub fn generate_open_type_from_open_api(
  _place_generation: PlaceGeneration,
  _custom_type_info: CustomTypeInfo,
  _module_data: ModuleInfo,
) {
  "Some generated code for open api like
  I'm to lazy for that (:
    pub type TypeFromOpenApi {
      TypeFromOpenApi(a: String, b: String, eeeeeeeeeeee: String)
    }
  "
}

pub fn generate_some_fn_and_types_in_module(
  _module_data: ModuleInfo,
  _place_generation: PlaceGeneration,
) {
  #(
    "module_name",
    "
      ///module generated by generate_some_fn_and_types_in_module
      import gleam/json
      type Rush {
        RushE,
        RushC,
        RushB
    }
  ",
  )
}

pub fn generator_run_through_existing_all_function(function_code: String) {
  #(
    "let some_var",
    RegexSourceGeneratorData(Replace, "io.pintln(string.inspect(some_var))"),
  )
}

pub fn generator_run_through_existing_case_statement(case_code: String) {
  #(
    "let some_var",
    RegexSourceGeneratorData(Replace, "io.pintln(string.inspect(some_var))"),
  )
}

pub fn generator_run_through_existing_use_statement(use_code: String) {
  #(
    "let some_var",
    RegexSourceGeneratorData(Replace, "io.pintln(string.inspect(some_var))"),
  )
}

pub fn generator_run_through_existing_let_statement(let_statement: String) {
  #(
    "let some_var",
    RegexSourceGeneratorData(Replace, "io.pintln(string.inspect(some_var))"),
  )
}

/// it's function run through all functions in project
/// it returns [#("some_regex","let some_code = \"that need be writed\"")]
/// that should be in gleam/source_generator
/// in gleam_stdlib
pub fn get_all_modules() -> List(String) {
  ["some/module", "some/module2"]
}

pub fn get_module_info(module_name: String) -> ModuleInfo {
  todo
}

pub fn get_function_info(function_name: String) -> FunctionData {
  todo
}

pub fn get_type_info(type_name: String) -> CustomTypeInfo {
  todo
}

pub fn get_record_type_info(
  type_name: String,
  record_name: String,
) -> RecordData {
  todo
}

//and more get functions

fn gleam_type_to_json_type(
  json_input_parametr_name: String,
  gleam_type: GleamType,
  attribute_parameters: List(#(String, String)),
) {
  case gleam_type {
    Bool -> Ok("json.bool")
    CustomType(info) ->
      gleam_custom_type_to_json(
        json_input_parametr_name,
        info.type_name,
        info.records,
        attribute_parameters,
      )
    Function(_) -> Error("Cannot deserilize function type")
    Int -> Ok("json.int")
    List(_) ->
      Error(
        "i'm to lazy for it. It's just example of usage source generator api",
      )
    String -> Ok("json.string")
    Generic(_) -> Error("Generic type not supported")
  }
}

pub fn replace(
  in format_string: String,
  replace label: String,
  with data: a,
) -> String {
  let to_replace = "{" <> label <> "}"
  string.replace(
    in: format_string,
    each: to_replace,
    with: string.inspect(data),
  )
}

pub fn format(str: String, values: List(#(String, String))) {
  case values {
    [] -> str
    [value, ..rest] -> str |> replace(value.0, value.1) |> format(rest)
  }
}
